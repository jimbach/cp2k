./adqmmmx_create.F:!> \note changed names (qmmmx->adqmmmx)
./adqmmmx_create.F:MODULE adqmmmx_create
./adqmmmx_create.F:   USE adqmmmx_types,                   ONLY: adqmmmx_env_type
./adqmmmx_create.F:   USE adqmmmx_util,                    ONLY: setup_adqmmmx_sections,&
./adqmmmx_create.F:                                              update_adqmmmx_labels,&
./adqmmmx_create.F:                                              get_adqmmmx_values
./adqmmmx_create.F:   CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'adqmmmx_create'
./adqmmmx_create.F:   PUBLIC :: adqmmmx_env_create
./adqmmmx_create.F:!> \param adqmmmx_env ...
./adqmmmx_create.F:!> \note adjusted names (qmmmx->adqmmmx)
./adqmmmx_create.F:   SUBROUTINE adqmmmx_env_create(adqmmmx_env, root_section, para_env, globenv, &
./adqmmmx_create.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./adqmmmx_create.F:      CHARACTER(len=*), PARAMETER :: routineN = 'adqmmmx_env_create', &
./adqmmmx_create.F:      ALLOCATE (adqmmmx_env)
./adqmmmx_create.F:      CALL get_adqmmmx_values(qmmm_section, adqmmmx_env, output_unit)
./adqmmmx_create.F:      IF (adqmmmx_env%lambda_adqmmmx > 0.0) THEN
./adqmmmx_create.F:         WRITE (output_unit,*) "ADQMMMX Lambda", adqmmmx_env%lambda_adqmmmx
./adqmmmx_create.F:         CALL setup_adqmmmx_sections(subsys, qmmm_section, new_qmmm_section, use_old_indlab=.TRUE.)
./adqmmmx_create.F:         CALL qmmm_env_create(adqmmmx_env%oldsys, root_section, para_env, globenv, &
./adqmmmx_create.F:         CALL setup_adqmmmx_sections(subsys, qmmm_section, new_qmmm_section)
./adqmmmx_create.F:         CALL qmmm_env_create(adqmmmx_env%newsys, root_section, para_env, globenv, &
./adqmmmx_create.F:         !MN Here indices are updated, maybe grep old updates and store them in adqmmmx_env_type?
./adqmmmx_create.F:         adqmmmx_env%include_nc = .TRUE.
./adqmmmx_create.F:         CALL update_adqmmmx_labels(subsys, qmmm_section, include_nc=.TRUE., c_n_sw=adqmmmx_env%c_n_sw)
./adqmmmx_create.F:         CALL setup_adqmmmx_sections(subsys, qmmm_section, new_qmmm_section)      
./adqmmmx_create.F:         CALL qmmm_env_create(adqmmmx_env%oldsys, root_section, para_env, globenv, &
./adqmmmx_create.F:         CALL qmmm_env_create(adqmmmx_env%newsys, root_section, para_env, globenv, &
./adqmmmx_create.F:         WRITE (output_unit,*) "ADQMMMX | adqmmmx_env_create"
./adqmmmx_create.F:   END SUBROUTINE adqmmmx_env_create
./adqmmmx_create.F:END MODULE adqmmmx_create
./adqmmmx_force.F:MODULE adqmmmx_force
./adqmmmx_force.F:   USE qmmm_types_low,                  ONLY: adqmmmx_label_QM_core,&
./adqmmmx_force.F:                                              adqmmmx_label_QM_dynamics
./adqmmmx_force.F:   USE adqmmmx_types,                   ONLY: adqmmmx_env_type
./adqmmmx_force.F:   USE adqmmmx_util,                    ONLY: apply_adqmmmx_translate,&
./adqmmmx_force.F:   CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'adqmmmx_force'
./adqmmmx_force.F:   PUBLIC :: adqmmmx_calc_energy_force
./adqmmmx_force.F:!> \param adqmmmx_env ...
./adqmmmx_force.F:   SUBROUTINE adqmmmx_calc_energy_force(force_env, calc_force, consistent_energies, linres)
./adqmmmx_force.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./adqmmmx_force.F:      CHARACTER(len=*), PARAMETER :: routineN = 'adqmmmx_calc_energy_force', &
./adqmmmx_force.F:      adqmmmx_env => force_env%adqmmmx_env
./adqmmmx_force.F:      IF (ASSOCIATED(force_env%adqmmmx_env)) THEN
./adqmmmx_force.F:      WRITE(1335, *) "SWITCHING Active?", adqmmmx_env%switch_active
./adqmmmx_force.F:      CALL apply_adqmmmx_translate(adqmmmx_env, output_unit)
./adqmmmx_force.F:      IF (adqmmmx_env%switch_active) THEN
./adqmmmx_force.F:          CALL adqmmmx_calc_energy_force_low(adqmmmx_env%oldsys, calc_force, consistent_energies, linres, "oldsys")
./adqmmmx_force.F:          CALL adqmmmx_calc_energy_force_low(adqmmmx_env%newsys, calc_force, consistent_energies, linres, "newsys")
./adqmmmx_force.F:          CALL qmmm_env_get(adqmmmx_env%oldsys, subsys=subsys_qmmm_oldsys, potential_energy=epot1)
./adqmmmx_force.F:          CALL qmmm_env_get(adqmmmx_env%newsys, subsys=subsys_qmmm_newsys, potential_energy=epot2)
./adqmmmx_force.F:          CALL get_qs_env(adqmmmx_env%newsys%qs_env, input=force_env_section)
./adqmmmx_force.F:             adqmmmx_env%dpot         = epot1 - epot2
./adqmmmx_force.F:              adqmmmx_env%dpot = SIGN(0.d0, epot1 - epot2)
./adqmmmx_force.F:          IF (adqmmmx_env%dpot_sgn==0.0) THEN
./adqmmmx_force.F:              adqmmmx_env%dpot_sgn = SIGN(1.d0,epot1 - epot2)
./adqmmmx_force.F:              WRITE (1335,*) "Creating dpot_sgn: ", adqmmmx_env%dpot_sgn
./adqmmmx_force.F:          adqmmmx_env%lambda_force=-dg_of_lambda(adqmmmx_env%lambda_adqmmmx)*DABS(epot1 - epot2)
./adqmmmx_force.F:          WRITE(1335,*) "Lambda Force: ", adqmmmx_env%lambda_force
./adqmmmx_force.F:          CALL qmmm_env_get(adqmmmx_env%newsys, subsys=subsys_primary)
./adqmmmx_force.F:          glam = g_of_lambda(adqmmmx_env%lambda_adqmmmx)
./adqmmmx_force.F:          adqmmmx_env%totpot = totpot
./adqmmmx_force.F:          CALL fist_env_get(adqmmmx_env%newsys%fist_env, thermo=thermo,&
./adqmmmx_force.F:!         CALL get_connectivity(adqmmmx_env%oldsys%fist_env, "oldsys", 1335)
./adqmmmx_force.F:!         CALL get_connectivity(adqmmmx_env%newsys%fist_env, "newsys", 1335)
./adqmmmx_force.F:          adqmmmx_env%kin_e = kin_e
./adqmmmx_force.F:          adqmmmx_env%md_pot_e = epot2
./adqmmmx_force.F:!         WRITE(1335,*) "T; ", adqmmmx_env%prop_time*femtoseconds, "L: ",&
./adqmmmx_force.F:!                       adqmmmx_env%lambda_adqmmmx,"Pot1: ", epot1,&
./adqmmmx_force.F:          CALL adqmmmx_calc_energy_force_low(adqmmmx_env%newsys, calc_force, consistent_energies, linres, "newsys")
./adqmmmx_force.F:          CALL qmmm_env_get(adqmmmx_env%newsys, subsys=subsys_qmmm_newsys, potential_energy=epot2)
./adqmmmx_force.F:          CALL get_qs_env(adqmmmx_env%newsys%qs_env, input=force_env_section)
./adqmmmx_force.F:          CALL qmmm_env_get(adqmmmx_env%newsys, subsys=subsys_primary)
./adqmmmx_force.F:          adqmmmx_env%totpot = totpot
./adqmmmx_force.F:          CALL fist_env_get(adqmmmx_env%newsys%fist_env, thermo=thermo,&
./adqmmmx_force.F:          adqmmmx_env%kin_e = kin_e
./adqmmmx_force.F:          adqmmmx_env%md_pot_e = epot2
./adqmmmx_force.F:   END SUBROUTINE adqmmmx_calc_energy_force
./adqmmmx_force.F:   SUBROUTINE adqmmmx_calc_energy_force_low(qmmm_env, calc_force, consistent_energies, linres, label)
./adqmmmx_force.F:      CHARACTER(len=*), PARAMETER :: routineN = 'adqmmmx_calc_energy_force_low', &
./adqmmmx_force.F:      ! Turn off box translation, it was already performed by apply_adqmmmx_translate(),
./adqmmmx_force.F:   END SUBROUTINE adqmmmx_calc_energy_force_low
./adqmmmx_force.F:END MODULE adqmmmx_force
./adqmmmx_types.F:!> \note adjusted names (qmmmx->adqmmmx), added lambda values.
./adqmmmx_types.F:MODULE adqmmmx_types
./adqmmmx_types.F:   CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'adqmmmx_types'
./adqmmmx_types.F:   PUBLIC :: adqmmmx_env_type, adqmmmx_env_get, adqmmmx_env_retain, adqmmmx_env_release
./adqmmmx_types.F:   TYPE adqmmmx_env_type
./adqmmmx_types.F:!     TYPE(adqmmmx_energy_type), POINTER                      :: 
./adqmmmx_types.F:      REAL(KIND=dp)                                           :: lambda_adqmmmx = 0.0      
./adqmmmx_types.F:   END TYPE adqmmmx_env_type
./adqmmmx_types.F:!> \note Adjustes names (qmmmx->adqmmmx)
./adqmmmx_types.F:!> \param adqmmmx_env ...
./adqmmmx_types.F:   SUBROUTINE adqmmmx_env_get(adqmmmx_env, subsys, potential_energy, kinetic_energy)
./adqmmmx_types.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./adqmmmx_types.F:      CHARACTER(len=*), PARAMETER :: routineN = 'adqmmmx_env_get', routineP = moduleN//':'//routineN
./adqmmmx_types.F:      CPASSERT(ASSOCIATED(adqmmmx_env))
./adqmmmx_types.F:      CPASSERT(adqmmmx_env%ref_count > 0)
./adqmmmx_types.F:      CALL qmmm_env_get(adqmmmx_env%oldsys, &
./adqmmmx_types.F:      CALL qmmm_env_get(adqmmmx_env%newsys, &
./adqmmmx_types.F:   END SUBROUTINE adqmmmx_env_get
./adqmmmx_types.F:!> \note Adjustes names (qmmmx->adqmmmx)
./adqmmmx_types.F:   SUBROUTINE adqmmmx_env_retain(adqmmmx_env)
./adqmmmx_types.F:      TYPE(adqmmmx_env_type), POINTER                      :: adqmmmx_env
./adqmmmx_types.F:      CHARACTER(len=*), PARAMETER :: routineN = 'adqmmmx_env_retain', &
./adqmmmx_types.F:      CPASSERT(ASSOCIATED(adqmmmx_env))
./adqmmmx_types.F:      CPASSERT(adqmmmx_env%ref_count > 0)
./adqmmmx_types.F:      adqmmmx_env%ref_count = adqmmmx_env%ref_count + 1
./adqmmmx_types.F:   END SUBROUTINE adqmmmx_env_retain
./adqmmmx_types.F:!> \brief releases the given adqmmmx_env
./adqmmmx_types.F:!> \note Adjustes names (qmmmx->adqmmmx)
./adqmmmx_types.F:!> \param adqmmmx_env the object to release
./adqmmmx_types.F:   SUBROUTINE adqmmmx_env_release(adqmmmx_env)
./adqmmmx_types.F:      TYPE(adqmmmx_env_type), POINTER                      :: adqmmmx_env
./adqmmmx_types.F:      CHARACTER(len=*), PARAMETER :: routineN = 'adqmmmx_env_release', &
./adqmmmx_types.F:      IF (ASSOCIATED(adqmmmx_env)) THEN
./adqmmmx_types.F:         CPASSERT(adqmmmx_env%ref_count > 0)
./adqmmmx_types.F:         adqmmmx_env%ref_count = adqmmmx_env%ref_count - 1
./adqmmmx_types.F:         IF (adqmmmx_env%ref_count == 0) THEN
./adqmmmx_types.F:            CALL qmmm_env_release(adqmmmx_env%oldsys)
./adqmmmx_types.F:            CALL qmmm_env_release(adqmmmx_env%newsys)
./adqmmmx_types.F:            DEALLOCATE (adqmmmx_env)
./adqmmmx_types.F:      NULLIFY (adqmmmx_env)
./adqmmmx_types.F:   END SUBROUTINE adqmmmx_env_release
./adqmmmx_types.F:END MODULE adqmmmx_types
./adqmmmx_update.F:MODULE adqmmmx_update
./adqmmmx_update.F:   USE adqmmmx_types,                   ONLY: adqmmmx_env_release,&
./adqmmmx_update.F:                                              adqmmmx_env_get,&
./adqmmmx_update.F:                                              adqmmmx_env_type
./adqmmmx_update.F:   USE adqmmmx_util,                    ONLY: setup_adqmmmx_sections,&
./adqmmmx_update.F:                                              update_adqmmmx_labels,&
./adqmmmx_update.F:                                              update_adqmmmx_values,&
./adqmmmx_update.F:!                                             print_adqmmmx_output,&
./adqmmmx_update.F:                                              copy_adqmmmx_env,&
./adqmmmx_update.F:                                              !old_update_adqmmmx_labels,&
./adqmmmx_update.F:   CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'adqmmmx_update'
./adqmmmx_update.F:   PUBLIC :: adqmmmx_update_force_env, adqmmmx_vv_second
./adqmmmx_update.F:!> \note Updated names (qmmmx->adqmmmx)
./adqmmmx_update.F:   SUBROUTINE adqmmmx_update_force_env(force_env, root_section, dt)
./adqmmmx_update.F:      CHARACTER(len=*), PARAMETER :: routineN = 'adqmmmx_update_force_env', routineP = moduleN//':'//routineN
./adqmmmx_update.F:      LOGICAL                                            :: file_exists,labels_changed, adqmmmx_active,&
./adqmmmx_update.F:      TYPE(adqmmmx_env_type), POINTER                    :: new_adqmmmx_env
./adqmmmx_update.F:                                                            adqmmmx_section, qmmm_section, &
./adqmmmx_update.F:      IF (ASSOCIATED(force_env%adqmmmx_env)) THEN
./adqmmmx_update.F:!     IF ( force_env%adqmmmx_env%oldsys .EQ. force_env%adqmmmx_env%newsys) THEN
./adqmmmx_update.F:!        force_env%adqmmmx_env%switch_active=.FALSE.
./adqmmmx_update.F:      IF ( force_env%adqmmmx_env%dpot == 0.0) THEN
./adqmmmx_update.F:         force_env%adqmmmx_env%switch_active=.FALSE.
./adqmmmx_update.F:         force_env%adqmmmx_env%lambda_adqmmmx=1.d0
./adqmmmx_update.F:         force_env%adqmmmx_env%lambda_velocity=0.d0
./adqmmmx_update.F:      ELSE IF (.NOT. ASSOCIATED(force_env%adqmmmx_env)) THEN
./adqmmmx_update.F:      lambda => force_env%adqmmmx_env%lambda_adqmmmx
./adqmmmx_update.F:!     IF (force_env%adqmmmx_env%prop_time==0) CALL print_adqmmmx_output(force_env%adqmmmx_env)
./adqmmmx_update.F:      force_env%adqmmmx_env%prop_time = force_env%adqmmmx_env%prop_time + dt
./adqmmmx_update.F:      adqmmmx_section => section_vals_get_subs_vals(qmmm_section, "ADAPTIVE_QMMM", can_return_null=.TRUE.) 
./adqmmmx_update.F:      CALL section_vals_val_get(adqmmmx_section, "DISCRETE_INTEGRATION", l_val=lam_int_disc)
./adqmmmx_update.F:      CALL section_vals_val_get(adqmmmx_section, "MAX_N_SWITCH",i_val=max_n_sw)
./adqmmmx_update.F:      IF ((force_env%adqmmmx_env%c_n_sw>max_n_sw) .AND. (max_n_sw/=-1)) THEN
./adqmmmx_update.F:                        force_env%adqmmmx_env%c_n_sw
./adqmmmx_update.F:             .AND. (force_env%adqmmmx_env%switch_active)) THEN
./adqmmmx_update.F:         IF (force_env%adqmmmx_env%lambda_mass == 0.d0) THEN
./adqmmmx_update.F:            CALL section_vals_val_get(adqmmmx_section, "SWITCH_T", r_val=switch_t)
./adqmmmx_update.F:               force_env%adqmmmx_env%lambda_mass = (2*DABS(force_env%adqmmmx_env%dpot)*switch_t**2)/&
./adqmmmx_update.F:               force_env%adqmmmx_env%lambda_mass = (2*DABS(force_env%adqmmmx_env%dpot)*switch_t**2)/&
./adqmmmx_update.F:            WRITE (1337,*) "MASS: ", force_env%adqmmmx_env%lambda_mass
./adqmmmx_update.F:      ELSE IF ((lambda >= 1) .OR. (.NOT. force_env%adqmmmx_env%switch_active)) THEN
./adqmmmx_update.F:         WRITE (1337,*) "Switch Active:", force_env%adqmmmx_env%switch_active
./adqmmmx_update.F:         IF (force_env%adqmmmx_env%energy_add) THEN
./adqmmmx_update.F:            Lam_Error = force_env%adqmmmx_env%dpot*(lambda - 1)**2
./adqmmmx_update.F:            WRITE (1337,*) "Total E_l is updated. OLD: ", force_env%adqmmmx_env%Tot_Elambda,&
./adqmmmx_update.F:                           "Added E: ", force_env%adqmmmx_env%Elambda,&
./adqmmmx_update.F:            force_env%adqmmmx_env%Tot_Elambda     = force_env%adqmmmx_env%Tot_Elambda+&
./adqmmmx_update.F:                                          force_env%adqmmmx_env%Elambda + Lam_Error+&
./adqmmmx_update.F:                                          force_env%adqmmmx_env%Elamcorr
./adqmmmx_update.F:            force_env%adqmmmx_env%Elamcorr        = 0.d0
./adqmmmx_update.F:            force_env%adqmmmx_env%Elambda         = 0.d0
./adqmmmx_update.F:            force_env%adqmmmx_env%lambda_velocity = 0.d0
./adqmmmx_update.F:            force_env%adqmmmx_env%energy_add      =.FALSE.
./adqmmmx_update.F:         force_env%adqmmmx_env%switch_active   = .FALSE.
./adqmmmx_update.F:      IF (.NOT. ASSOCIATED(adqmmmx_section)) RETURN
./adqmmmx_update.F:      CALL section_vals_get(adqmmmx_section, explicit=adqmmmx_active)
./adqmmmx_update.F:      WRITE (1337,*) "adqmmmx_active= ", adqmmmx_active
./adqmmmx_update.F:      IF (.NOT. ASSOCIATED(force_env%adqmmmx_env)) CPABORT("force_env%adqmmmx_env not associated")
./adqmmmx_update.F:      IF (.NOT. ASSOCIATED(qmmm_section) .OR. .NOT. ASSOCIATED(adqmmmx_section)) THEN
./adqmmmx_update.F:         WRITE (1337,*) "UPDATE_FORCE_ENV: PROBLEM WITH QMMM section", ASSOCIATED(qmmm_section), ASSOCIATED(adqmmmx_section)
./adqmmmx_update.F:      IF ( .NOT. force_env%adqmmmx_env%switch_active ) THEN 
./adqmmmx_update.F:         !MN Create new_adqmmmx_env
./adqmmmx_update.F:         ALLOCATE (new_adqmmmx_env)
./adqmmmx_update.F:         CALL setup_adqmmmx_sections(subsys, qmmm_section, qmmm_oldsys_section)
./adqmmmx_update.F:         CALL qmmm_env_create(new_adqmmmx_env%oldsys, &
./adqmmmx_update.F:         CALL qmmm_env_get(force_env%adqmmmx_env%newsys, subsys=subsys)
./adqmmmx_update.F:         CALL qmmm_env_get(new_adqmmmx_env%oldsys, subsys=subsys)
./adqmmmx_update.F:         CALL qmmm_env_get(new_adqmmmx_env%oldsys, subsys=subsys_new)
./adqmmmx_update.F:         CALL update_adqmmmx_labels(subsys,qmmm_section,labels_changed=labels_changed,&
./adqmmmx_update.F:               include_nc=force_env%adqmmmx_env%include_nc,c_n_sw=force_env%adqmmmx_env%c_n_sw)
./adqmmmx_update.F:               force_env%adqmmmx_env%switch_active=.FALSE.
./adqmmmx_update.F:               CALL adqmmmx_env_release(new_adqmmmx_env)
./adqmmmx_update.F:         WRITE(1337,*) "Update_force_eval called. Now create new adqmmmx environment"
./adqmmmx_update.F:         CALL setup_adqmmmx_sections(subsys, qmmm_section, qmmm_newsys_section)
./adqmmmx_update.F:         CALL qmmm_env_create(new_adqmmmx_env%newsys, &
./adqmmmx_update.F:         WRITE (1337,*) "NEWSYS ASSOCIATED", ASSOCIATED(new_adqmmmx_env%newsys), new_adqmmmx_env%newsys%ref_count
./adqmmmx_update.F:         CALL qmmm_env_get(force_env%adqmmmx_env%newsys, subsys=subsys_new)
./adqmmmx_update.F:         CALL qmmm_env_get(new_adqmmmx_env%newsys, subsys=subsys_new)
./adqmmmx_update.F:         CALL copy_adqmmmx_env(new_adqmmmx_env, force_env%adqmmmx_env)
./adqmmmx_update.F:         CALL adqmmmx_env_release(force_env%adqmmmx_env)
./adqmmmx_update.F:         force_env%adqmmmx_env => new_adqmmmx_env
./adqmmmx_update.F:      IF ( force_env%adqmmmx_env%switch_active ) THEN
./adqmmmx_update.F:         !MN adqmmmx_section empty?
./adqmmmx_update.F:         CALL section_vals_val_get(adqmmmx_section, "SWITCH_T", r_val=switch_t)
./adqmmmx_update.F:         WRITE(1337,*) "ADQMMMX_SECTION ASS:", ASSOCIATED(adqmmmx_section), "SWITCH_T:", switch_t/4
./adqmmmx_update.F:         force_env%adqmmmx_env%do_discrete = lam_int_disc
./adqmmmx_update.F:         WRITE(1337,*) "LAM_INT_DISC: ", lam_int_disc,force_env%adqmmmx_env%do_discrete
./adqmmmx_update.F:            CALL lambda_propagation_discrete(force_env%adqmmmx_env, dt, 1337)
./adqmmmx_update.F:            CALL lambda_propagation(force_env%adqmmmx_env, switch_t, dt, 1337)
./adqmmmx_update.F:         WRITE (1337,*) "Elambda = ", force_env%adqmmmx_env%Elambda, "TOT_Elambda = ", force_env%adqmmmx_env%Tot_Elambda
./adqmmmx_update.F:         force_env%adqmmmx_env%switch_active = .TRUE.
./adqmmmx_update.F:      !MN adqmmmx values in restart file
./adqmmmx_update.F:      CALL update_adqmmmx_values(adqmmmx_section, force_env%adqmmmx_env, 1337)
./adqmmmx_update.F:   END SUBROUTINE adqmmmx_update_force_env
./adqmmmx_update.F:   SUBROUTINE lambda_propagation(adqmmmx_env, switch_t, dt, output_unit)
./adqmmmx_update.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./adqmmmx_update.F:      lambda = adqmmmx_env%lambda_adqmmmx
./adqmmmx_update.F:      prop_time = adqmmmx_env%prop_time
./adqmmmx_update.F:      vlambda = adqmmmx_env%lambda_velocity
./adqmmmx_update.F:      dpot = adqmmmx_env%dpot
./adqmmmx_update.F:      mlambda = adqmmmx_env%lambda_mass
./adqmmmx_update.F:      adqmmmx_env%omega = omega
./adqmmmx_update.F:      adqmmmx_env%lambda_adqmmmx   = lambda
./adqmmmx_update.F:      adqmmmx_env%lambda_velocity  = vlambda
./adqmmmx_update.F:   SUBROUTINE lambda_propagation_discrete(adqmmmx_env, dt, output_unit)
./adqmmmx_update.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./adqmmmx_update.F:      test_F = -2*adqmmmx_env%dpot*(adqmmmx_env%lambda_adqmmmx - 1)
./adqmmmx_update.F:      adqmmmx_env%lambda_velocity = adqmmmx_env%lambda_velocity + &
./adqmmmx_update.F:                           0.5*dt*(adqmmmx_env%lambda_force/adqmmmx_env%lambda_mass) 
./adqmmmx_update.F:      adqmmmx_env%lambda_adqmmmx = adqmmmx_env%lambda_adqmmmx + dt*adqmmmx_env%lambda_velocity
./adqmmmx_update.F:      WRITE (output_unit,*) "Half V_Lam: ", adqmmmx_env%lambda_velocity
./adqmmmx_update.F:      WRITE (output_unit,*) "Acc.: ", adqmmmx_env%lambda_force/adqmmmx_env%lambda_mass
./adqmmmx_update.F:   SUBROUTINE adqmmmx_vv_second(force_env, dt, output_unit)
./adqmmmx_update.F:      IF (force_env%adqmmmx_env%lambda_adqmmmx==0.0) THEN
./adqmmmx_update.F:      IF (.NOT. ASSOCIATED(force_env%adqmmmx_env) ) RETURN
./adqmmmx_update.F:                             force_env%adqmmmx_env%do_discrete,&
./adqmmmx_update.F:                             force_env%adqmmmx_env%energy_add
./adqmmmx_update.F:      IF ( (.NOT. force_env%adqmmmx_env%do_discrete) .AND. (force_env%adqmmmx_env%energy_add)) THEN
./adqmmmx_update.F:      test_F = -2*force_env%adqmmmx_env%dpot*(force_env%adqmmmx_env%lambda_adqmmmx - 1)
./adqmmmx_update.F:      force_env%adqmmmx_env%lambda_velocity = force_env%adqmmmx_env%lambda_velocity +&
./adqmmmx_update.F:      0.5*dt*(force_env%adqmmmx_env%lambda_force/force_env%adqmmmx_env%lambda_mass) 
./adqmmmx_update.F:      WRITE(output_unit,*) "Full V_Lam: ", force_env%adqmmmx_env%lambda_velocity
./adqmmmx_update.F:      WRITE (output_unit,*) "New F_Lam: ", force_env%adqmmmx_env%lambda_force,&
./adqmmmx_update.F:END MODULE adqmmmx_update
./adqmmmx_util.F:MODULE adqmmmx_util
./adqmmmx_util.F:   USE qmmm_types_low,                  ONLY: adqmmmx_label_QM_core,&
./adqmmmx_util.F:                                              adqmmmx_label_QM_core_list,&
./adqmmmx_util.F:                                              adqmmmx_label_QM_dynamics,&
./adqmmmx_util.F:                                              adqmmmx_label_QM_dynamics_list,&
./adqmmmx_util.F:                                              adqmmmx_label_QM_starting,&
./adqmmmx_util.F:                                              adqmmmx_label_QM_starting_list,&
./adqmmmx_util.F:                                              adqmmmx_label_none,&
./adqmmmx_util.F:                                              adqmmmx_label_termination
./adqmmmx_util.F:   USE adqmmmx_types,                   ONLY: adqmmmx_env_type
./adqmmmx_util.F:   CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'adqmmmx_util'
./adqmmmx_util.F:   PUBLIC :: setup_adqmmmx_sections, update_adqmmmx_labels, &
./adqmmmx_util.F:             apply_adqmmmx_translate, dg_of_lambda, g_of_lambda, &
./adqmmmx_util.F:             get_adqmmmx_values, update_adqmmmx_values, &
./adqmmmx_util.F:             print_adqmmmx_output, copy_adqmmmx_env
./adqmmmx_util.F:             !&,old_update_adqmmmx_labels
./adqmmmx_util.F:!> \param adqmmmx_env ...
./adqmmmx_util.F:   SUBROUTINE apply_adqmmmx_translate(adqmmmx_env, output_unit)
./adqmmmx_util.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./adqmmmx_util.F:      CHARACTER(len=*), PARAMETER :: routineN = 'apply_adqmmmx_translate', &
./adqmmmx_util.F:      CALL apply_qmmm_translate(adqmmmx_env%newsys)
./adqmmmx_util.F:      WRITE (output_unit,*) "ENV CHECK ", ASSOCIATED(adqmmmx_env)
./adqmmmx_util.F:      CALL qmmm_env_get(adqmmmx_env%newsys, subsys=subsys_newsys)
./adqmmmx_util.F:      CALL qmmm_env_get(adqmmmx_env%oldsys, subsys=subsys_oldsys)
./adqmmmx_util.F:!     CALL apply_qmmm_translate(adqmmmx_env%newsys)
./adqmmmx_util.F:!     CALL apply_qmmm_translate(adqmmmx_env%oldsys)
./adqmmmx_util.F:   END SUBROUTINE apply_adqmmmx_translate
./adqmmmx_util.F:   SUBROUTINE update_adqmmmx_labels(subsys,qmmm_section,labels_changed,include_nc, c_n_sw)
./adqmmmx_util.F:      TYPE(section_vals_type), POINTER                   :: qmmm_section, adqmmmx_section,&
./adqmmmx_util.F:      CALL get_adqmmmx_indices(qmmm_section, cur_indices,cur_labels)
./adqmmmx_util.F:      adqmmmx_section => section_vals_get_subs_vals3(qmmm_section,"ADAPTIVE_QMMM")
./adqmmmx_util.F:      CALL section_vals_val_get(adqmmmx_section, "R_QM", r_vals=r_qm)
./adqmmmx_util.F:      CALL section_vals_val_get(adqmmmx_section, "MAX_N_QM", i_val=max_n_qm)
./adqmmmx_util.F:      new_labels  = adqmmmx_label_none
./adqmmmx_util.F:      starting_qm_labels  = adqmmmx_label_none
./adqmmmx_util.F:      CALL section_vals_val_get(adqmmmx_section, "QM_CORE", i_vals=qm_core)
./adqmmmx_util.F:                  new_labels(ind_counter)  = adqmmmx_label_QM_core
./adqmmmx_util.F:                  starting_qm_labels(starting_qm_counter) = adqmmmx_label_QM_starting
./adqmmmx_util.F:      CALL make_neighbor_list(adqmmmx_section, subsys, cell, r_qm(2), nlist)
./adqmmmx_util.F:               new_labels(ind_counter) = adqmmmx_label_QM_starting
./adqmmmx_util.F:                              ip," With label ", adqmmmx_label_QM_starting
./adqmmmx_util.F:                  new_labels(ind_counter) = adqmmmx_label_QM_dynamics
./adqmmmx_util.F:                              ip," With label ", adqmmmx_label_QM_dynamics
./adqmmmx_util.F:         CALL section_vals_val_get(adqmmmx_section, "MAX_N_SWITCH", i_val=max_n_sw)
./adqmmmx_util.F:      !MN Catches the case of adqmmmx_create
./adqmmmx_util.F:            CALL get_adqmmmx_indices(qmmm_section, cur_indices, cur_labels)
./adqmmmx_util.F:            " N_QM core     ", COUNT(new_labels == adqmmmx_label_QM_core), &
./adqmmmx_util.F:            " N_QM starting ", COUNT(new_labels == adqmmmx_label_QM_starting), &
./adqmmmx_util.F:            " N_QM dynamic  ", COUNT(new_labels == adqmmmx_label_QM_dynamics)
./adqmmmx_util.F:   END SUBROUTINE update_adqmmmx_labels
./adqmmmx_util.F:  SUBROUTINE get_adqmmmx_values(qmmm_section, adqmmmx_env, output_unit)
./adqmmmx_util.F:     TYPE(adqmmmx_env_type), POINTER, OPTIONAL          :: adqmmmx_env
./adqmmmx_util.F:                                                           adqmmmx_section,&
./adqmmmx_util.F:     adqmmmx_section => section_vals_get_subs_vals(qmmm_section, "ADAPTIVE_QMMM", can_return_null=.TRUE.)
./adqmmmx_util.F:     CALL section_vals_val_get(adqmmmx_section, "MAX_N_SWITCH", i_val=max_n_sw)
./adqmmmx_util.F:       adqmmmx_env%c_n_sw=1
./adqmmmx_util.F:           adqmmmx_env%lambda_adqmmmx = dummy_lambda
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "VLAMBDA", r_val=adqmmmx_env%lambda_velocity)  
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "PROP_TIME", r_val=adqmmmx_env%prop_time)  
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "LMASS", r_val=adqmmmx_env%lambda_mass)  
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "OMEGA", r_val=adqmmmx_env%omega)  
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "DPOT", r_val=adqmmmx_env%dpot)  
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "LFORCE", r_val=adqmmmx_env%lambda_force)  
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "ELAMBDA", r_val=adqmmmx_env%Elambda)  
./adqmmmx_util.F:        CALL section_vals_val_get(restart_section, "TOTELAMBDA", r_val=adqmmmx_env%Tot_Elambda)  
./adqmmmx_util.F:        WRITE (output_unit,*) "UPDATED VALUES", adqmmmx_env%lambda_adqmmmx, &
./adqmmmx_util.F:                              adqmmmx_env%lambda_velocity, adqmmmx_env%lambda_mass
./adqmmmx_util.F:        IF (0.0 < adqmmmx_env%lambda_adqmmmx) THEN
./adqmmmx_util.F:           adqmmmx_env%switch_active=.TRUE.
./adqmmmx_util.F:           adqmmmx_env%labels_changed=.FALSE.
./adqmmmx_util.F:           adqmmmx_env%energy_add=.TRUE.
./adqmmmx_util.F:           adqmmmx_env%output_energies=.FALSE.
./adqmmmx_util.F:  END SUBROUTINE get_adqmmmx_values
./adqmmmx_util.F:  SUBROUTINE update_adqmmmx_values(adqmmmx_section, adqmmmx_env, output_unit)
./adqmmmx_util.F:     TYPE(adqmmmx_env_type), POINTER, OPTIONAL          :: adqmmmx_env
./adqmmmx_util.F:     TYPE(section_vals_type), POINTER                   :: adqmmmx_section,&
./adqmmmx_util.F:     restart_section => section_vals_get_subs_vals(adqmmmx_section, "RESTART_INFO")
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "LAMBDA", r_val=adqmmmx_env%lambda_adqmmmx)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "VLAMBDA", r_val=adqmmmx_env%lambda_velocity)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "PROP_TIME", r_val=adqmmmx_env%prop_time)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "LMASS", r_val=adqmmmx_env%lambda_mass)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "OMEGA", r_val=adqmmmx_env%omega)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "DPOT", r_val=adqmmmx_env%dpot)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "LFORCE", r_val=adqmmmx_env%lambda_force)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "ELAMBDA", r_val=adqmmmx_env%Elambda)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "ECORR", r_val=adqmmmx_env%Elamcorr)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "DPOT_SGN", r_val=adqmmmx_env%dpot_sgn)  
./adqmmmx_util.F:        CALL section_vals_val_set(restart_section, "TOTELAMBDA", r_val=adqmmmx_env%Tot_Elambda) 
./adqmmmx_util.F:        WRITE (output_unit,*) "RESTART SECTION WAS UPDATED", adqmmmx_env%lambda_adqmmmx
./adqmmmx_util.F:  END SUBROUTINE update_adqmmmx_values
./adqmmmx_util.F:  SUBROUTINE copy_adqmmmx_env(new_adqmmmx_env, adqmmmx_env)
./adqmmmx_util.F:         TYPE(adqmmmx_env_type), POINTER                    :: new_adqmmmx_env,&
./adqmmmx_util.F:                                                               adqmmmx_env
./adqmmmx_util.F:         new_adqmmmx_env%lambda_adqmmmx  = 0.0 
./adqmmmx_util.F:         new_adqmmmx_env%prop_time       = adqmmmx_env%prop_time
./adqmmmx_util.F:         new_adqmmmx_env%prop_time       = adqmmmx_env%prop_time
./adqmmmx_util.F:         new_adqmmmx_env%lambda_velocity = 0.0 
./adqmmmx_util.F:         new_adqmmmx_env%lambda_mass     = 0.0 
./adqmmmx_util.F:         new_adqmmmx_env%omega           = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%dpot            = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%totpot          = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%kin_e           = adqmmmx_env%md_kin_e
./adqmmmx_util.F:         new_adqmmmx_env%md_kin_e        = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%md_pot_e        = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%md_corr         = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%lambda_force    = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%Elambda         = 0.0
./adqmmmx_util.F:         new_adqmmmx_env%Tot_Elambda     = adqmmmx_env%Tot_Elambda
./adqmmmx_util.F:         new_adqmmmx_env%Elamcorr        = adqmmmx_env%Elamcorr
./adqmmmx_util.F:         new_adqmmmx_env%dpot_sgn        = adqmmmx_env%dpot_sgn
./adqmmmx_util.F:         new_adqmmmx_env%switch_active   = .FALSE.
./adqmmmx_util.F:         new_adqmmmx_env%do_discrete    = adqmmmx_env%do_discrete
./adqmmmx_util.F:         new_adqmmmx_env%include_nc      = .FALSE.
./adqmmmx_util.F:         IF (.NOT. adqmmmx_env%c_n_sw==-1) THEN
./adqmmmx_util.F:           new_adqmmmx_env%c_n_sw = adqmmmx_env%c_n_sw + 1
./adqmmmx_util.F:  END SUBROUTINE copy_adqmmmx_env
./adqmmmx_util.F:               new_labels(ind_counter)  = adqmmmx_label_QM_dynamics
./adqmmmx_util.F:      IF (new_full_labels(ip) > adqmmmx_label_none) THEN ! already marked, just change mark
./adqmmmx_util.F:   SUBROUTINE make_neighbor_list(adqmmmx_section, subsys, cell, r_max, nlist)
./adqmmmx_util.F:      TYPE(section_vals_type), POINTER                   :: adqmmmx_section
./adqmmmx_util.F:                                     mm_section=adqmmmx_section)
./adqmmmx_util.F:   SUBROUTINE setup_adqmmmx_sections(subsys, qmmm_section, new_qmmm_section, use_old_indlab)
./adqmmmx_util.F:      CHARACTER(len=*), PARAMETER :: routineN = 'setup_adqmmmx_sections', &
./adqmmmx_util.F:      TYPE(section_vals_type), POINTER                   :: adqmmmx_section, &
./adqmmmx_util.F:      adqmmmx_section => section_vals_get_subs_vals(qmmm_section, "ADAPTIVE_QMMM")
./adqmmmx_util.F:      CALL section_vals_val_get(adqmmmx_section, "QM_KIND_ELEMENT_MAPPING", n_rep_val=n_elements)
./adqmmmx_util.F:         CALL section_vals_val_get(adqmmmx_section, "QM_KIND_ELEMENT_MAPPING", i_rep_val=ielem, c_vals=elem_mapping_entry)
./adqmmmx_util.F:      IF (PRESENT(use_old_indlab) .AND. use_old_indlab) THEN !MN Only used for adqmmmx_create.F
./adqmmmx_util.F:         CALL get_adqmmmx_indices(qmmm_section, cur_indices, cur_labels, use_old_indlab)
./adqmmmx_util.F:         CALL get_adqmmmx_indices(qmmm_section, cur_indices, cur_labels)
./adqmmmx_util.F:!       IF (cur_labels(ip) > adqmmmx_label_none .AND. cur_labels(ip) /= adqmmmx_label_QM_core .AND. &
./adqmmmx_util.F:!           cur_labels(ip) /= adqmmmx_label_QM_starting .AND. cur_labels(ip) /= adqmmmx_label_termination) THEN
./adqmmmx_util.F:        IF (cur_labels(ip) > adqmmmx_label_termination) THEN
./adqmmmx_util.F:            IF ((cur_labels(ip) == adqmmmx_label_QM_core) .OR. &
./adqmmmx_util.F:                (cur_labels(ip) == adqmmmx_label_QM_dynamics) .OR. &
./adqmmmx_util.F:                (cur_labels(ip) == adqmmmx_label_QM_starting)) THEN
./adqmmmx_util.F:   END SUBROUTINE setup_adqmmmx_sections
./adqmmmx_util.F:   SUBROUTINE get_adqmmmx_indices(qmmm_section, indices, labels, use_old_indlab)
./adqmmmx_util.F:      TYPE(section_vals_type), POINTER                   :: qmmm_section,adqmmmx_section,&
./adqmmmx_util.F:      CHARACTER(len=*), PARAMETER :: routineN = 'get_adqmmmx_indices', &
./adqmmmx_util.F:      adqmmmx_section => section_vals_get_subs_vals3(qmmm_section, "ADAPTIVE_QMMM")
./adqmmmx_util.F:      restart_section => section_vals_get_subs_vals(adqmmmx_section, "RESTART_INFO")
./adqmmmx_util.F:     IF ((PRESENT(use_old_indlab) .AND. (use_old_indlab))) THEN !MN Only used in adqmmmx_create.F
./adqmmmx_util.F:         CALL section_vals_val_get(adqmmmx_section, "QM_CORE", i_vals=qm_core)
./adqmmmx_util.F:                        labels(ind_counter)  = adqmmmx_label_QM_core
./adqmmmx_util.F:                        labels(ind_counter)  = adqmmmx_label_QM_starting
./adqmmmx_util.F:         CPWARN("got unequal numbers of adqmmmx indices and labels!")
./adqmmmx_util.F:   END SUBROUTINE get_adqmmmx_indices
./adqmmmx_util.F:   SUBROUTINE print_adqmmmx_output(adqmmmx_env)
./adqmmmx_util.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./adqmmmx_util.F:      LOGICAL                                            :: file_exists, adqmmmx_first_call=.FALSE.
./adqmmmx_util.F:      IF(.NOT. ASSOCIATED(adqmmmx_env)) RETURN
./adqmmmx_util.F:         adqmmmx_first_call = .TRUE.
./adqmmmx_util.F:      IF ((adqmmmx_env%output_energies) .OR. (adqmmmx_first_call)) THEN
./adqmmmx_util.F:         time        => adqmmmx_env%prop_time
./adqmmmx_util.F:         dpot        => adqmmmx_env%dpot
./adqmmmx_util.F:         totpot      => adqmmmx_env%totpot
./adqmmmx_util.F:         md_corr     => adqmmmx_env%md_corr
./adqmmmx_util.F:         elambda     => adqmmmx_env%Elambda
./adqmmmx_util.F:         elamcorr    => adqmmmx_env%Elamcorr
./adqmmmx_util.F:         tot_elambda => adqmmmx_env%Tot_Elambda
./adqmmmx_util.F:         constant    => adqmmmx_env%constant
./adqmmmx_util.F:         IF (adqmmmx_env%kin_e >= adqmmmx_env%md_kin_e) THEN
./adqmmmx_util.F:                 kin_e => adqmmmx_env%kin_e
./adqmmmx_util.F:                 kin_e => adqmmmx_env%md_kin_e
./adqmmmx_util.F:         adqmmmx_first_call = .TRUE.
./adqmmmx_util.F:      IF ((adqmmmx_env%output_energies) .OR. (adqmmmx_first_call)) THEN
./adqmmmx_util.F:         kin_e   => adqmmmx_env%md_kin_e
./adqmmmx_util.F:         md_corr => adqmmmx_env%md_corr
./adqmmmx_util.F:         dpot    => adqmmmx_env%dpot
./adqmmmx_util.F:         totpot  => adqmmmx_env%md_pot_e
./adqmmmx_util.F:         adqmmmx_first_call = .TRUE.
./adqmmmx_util.F:         vlambda     => adqmmmx_env%lambda_velocity
./adqmmmx_util.F:         mlambda     => adqmmmx_env%lambda_mass
./adqmmmx_util.F:         flambda     => adqmmmx_env%lambda_force
./adqmmmx_util.F:   END SUBROUTINE print_adqmmmx_output
./adqmmmx_util.F:END MODULE adqmmmx_util
./f77_interface.F:                                              do_qmmm, do_qmmmx, do_qs, do_sirius, do_adqmmmx
./f77_interface.F:   USE adqmmmx_create,                  ONLY: adqmmmx_env_create
./f77_interface.F:   USE adqmmmx_types,                   ONLY: adqmmmx_env_release,&
./f77_interface.F:                                              adqmmmx_env_type
./f77_interface.F:      TYPE(adqmmmx_env_type), POINTER                    :: adqmmmx_env
./f77_interface.F:                                          fp_section, input_file, qmmm_section, qmmmx_section, adqmmmx_section, root_section, &
./f77_interface.F:            adqmmmx_section => section_vals_get_subs_vals(force_env_section, "QMMM%ADAPTIVE_QMMM")
./f77_interface.F:            CALL section_vals_get(adqmmmx_section, explicit=do_adaptive_qmmm)
./f77_interface.F:               method_name_id = do_adqmmmx ! QMMM Force-Mixing has its own (hidden) method_id
./f77_interface.F:!              WRITE (output_unit,*) "MN check of f77_interface.F if something is in adqmmmx_section"
./f77_interface.F:         CASE (do_adqmmmx)
./f77_interface.F:            CALL adqmmmx_env_create(adqmmmx_env, root_section, my_para_env, globenv, &
./f77_interface.F:            CALL force_env_create(my_force_env, root_section, adqmmmx_env=adqmmmx_env, para_env=my_para_env, &
./f77_interface.F:            CALL adqmmmx_env_release(adqmmmx_env)
./force_env_methods.F:        use_prog_name, use_pwdft_force, use_qmmm, use_qmmmx, use_adqmmmx, use_qs_force
./force_env_methods.F:   !JB Insert adqmmmx environment
./force_env_methods.F:   USE adqmmmx_force,                   ONLY: adqmmmx_calc_energy_force
./force_env_methods.F:   USE adqmmmx_types,                   ONLY: adqmmmx_env_retain,&
./force_env_methods.F:                                              adqmmmx_env_type
./force_env_methods.F:         CASE (use_adqmmmx)
./force_env_methods.F:            CALL adqmmmx_calc_energy_force(force_env, &
./force_env_methods.F:                               qs_env, meta_env, sub_force_env, qmmm_env, qmmmx_env, adqmmmx_env, eip_env, pwdft_env, & 
./force_env_methods.F:      TYPE(adqmmmx_env_type), OPTIONAL, POINTER          :: adqmmmx_env
./force_env_methods.F:               force_env%qmmm_env, force_env%qmmmx_env, force_env%adqmmmx_env, force_env%fp_env, &
./force_env_methods.F:      IF (PRESENT(adqmmmx_env)) THEN
./force_env_methods.F:         CPASSERT(ASSOCIATED(adqmmmx_env))
./force_env_methods.F:         force_env%in_use = use_adqmmmx
./force_env_methods.F:         force_env%adqmmmx_env => adqmmmx_env
./force_env_methods.F:         CALL adqmmmx_env_retain(adqmmmx_env) !JB I think here environments are loaded because retain number is increased here
./force_env_types.F:   !JB Added adqmmmx_env to routine assembly
./force_env_types.F:   USE adqmmmx_types,                   ONLY: adqmmmx_env_get,&
./force_env_types.F:                                              adqmmmx_env_release,&
./force_env_types.F:                                              adqmmmx_env_type
./force_env_types.F:                                 use_adqmmmx = 511 !JB Added
./force_env_types.F:      TYPE(adqmmmx_env_type), POINTER                  :: adqmmmx_env => NULL()
./force_env_types.F:            IF (ASSOCIATED(force_env%adqmmmx_env)) THEN
./force_env_types.F:               CALL adqmmmx_env_release(force_env%adqmmmx_env) !JB Added adqmmmx
./force_env_types.F:               DEALLOCATE (force_env%adqmmmx_env)
./force_env_types.F:                                      qmmm_env, qmmmx_env, adqmmmx_env, eip_env, pwdft_env, globenv, input, force_env_section, &
./force_env_types.F:      TYPE(adqmmmx_env_type), OPTIONAL, POINTER          :: adqmmmx_env 
./force_env_types.F:      CASE (use_adqmmmx) !JB Added full env_get-routine
./force_env_types.F:         CALL adqmmmx_env_get(force_env%adqmmmx_env, &
./force_env_types.F:      IF (PRESENT(adqmmmx_env)) adqmmmx_env => force_env%adqmmmx_env
./input_constants.F:                                               do_adqmmmx = 11
./qmmm_types_low.F:                                 adqmmmx_label_none = -1, &
./qmmm_types_low.F:                                 adqmmmx_label_QM_core_list = 10, &
./qmmm_types_low.F:                                 adqmmmx_label_QM_core = 9, &
./qmmm_types_low.F:                                 adqmmmx_label_QM_dynamics_list = 8, &
./qmmm_types_low.F:                                 adqmmmx_label_QM_dynamics = 7, &
./qmmm_types_low.F:                                 adqmmmx_label_QM_starting_list = 6, &
./qmmm_types_low.F:                                 adqmmmx_label_QM_starting = 5, &
./qmmm_types_low.F:                                 adqmmmx_label_termination = 4   
